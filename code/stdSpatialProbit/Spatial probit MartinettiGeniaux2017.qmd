---
title: "Failures 99-01 and 99-03-Different undirected Ws"
author: "Emi"
date: "`r format(Sys.time(), '%d %B, %Y')`"
date-meta: 27/10/2022
format: 
  html:
    code-fold: true
    code-tools: true
    toc: true
    toc-depth: 5
    max-width: 2000px
    embed-resources: true
    standalone: true
params:
  IDSAMS: "A98_W97_B2L_nz_99FT01q3
A98_W98_B2L_nz_99FT01q3
A98_W99t01q3_B2L_nz_99FT01
A98_W97rest_B2L_nz_99FT01q3
A98_W98rest_B2L_nz_99FT01q3
A98_W99t01q3NoRest_B2L_nz_99FT01
A98_W97_B2L_nz_99FT03q4
A98_W98_B2L_nz_99FT03q4
A98_W99t01q3NoRest_B2L_nz_99FT03
A98_W97rest_B2L_nz_99FT03q4
A98_W98rest_B2L_nz_99FT03q4
A98_W99t01q3_B2L_nz_99FT03
A98_W98und_B2L_nz_99FT01q3
A98_W98unw_B2L_nz_99FT01q3
A98_W97und_B2L_nz_99FT01q3
A98_W99t01q3und_B2L_nz_99FT01q3

"
  PSAR_COVAR: TRUE # ProbitSAR should std error be computed using the Var-Cov matrix?
execute:
  cache: FALSE
  eval: TRUE
#bibliography: [book.bib, packages.bib]
#biblio-style: apalike
---

```{r setup, include=FALSE}
library(mfx)
library(tidyverse)
library(lubridate)
library(tidygraph) # Plotting graphs
library("igraph", quietly = TRUE, warn.conflicts = FALSE, verbose = FALSE)
require(visNetwork)
library(readODS)
library(sandwich)
library(lmtest)
library(spdep)
library(spatialreg)
library(huxtable) # export tables (tibble) to Latex/Excel
library(Matrix)
library(ProbitSpatial)
library(texreg)

select <- dplyr::select # select() also exists in the MASS package loaded by mfx

source('../Rutils/Emi_R_utils.R')
source('../Rutils/texreg_extension_ProbitSpatial.R')
source('../Rutils/texreg_extension_sphet.R')
source('../BAFA_funs.R')

```


```{r}
# TODO: convert params$IDSAMS to a character vector. Then load samples in sams
samIDs <- str_trim(params$IDSAMS, side='both') %>% str_split(., " ", simplify=TRUE) %>% .[1,]

samSpecs <- read_ods("../../data/sams_specs_BAFA.ods") %>%
  filter(IDSAM %in% samIDs) %>%
  # how should results be ordered? useful for tables
  mutate(order = match(.$IDSAM, samIDs)) %>%
  arrange(., order)

if(NROW(samSpecs) == 0) { stop(paste("sams: ", samIDs, " not found!"))}
# Vars to reescale
cols <- c('C8Est_w', 'CAR_IRR_3A6', 'P_ROA', 'P_DEP_ARS_RATE', 'P_LOANS_ARS_RATE_W', 
'APRSpNF_RATE_W', 'APR_USD_RATE', 'APR_RATE_W')

Sams <- pmap(samSpecs, function(...) {
  thisSamSpec <- tibble(...)
  fileName <- paste0('../../', thisSamSpec$SAMSAVINGFOLDER, thisSamSpec$IDSAM, '.rds') 
  print(paste0("Opening ", fileName))
  thisSam <- readRDS(fileName)
  
  # Reescale certain vars
  thisSam$X <-  thisSam$X %>%
                  mutate(across(all_of(cols), ~.x/100))

  
  thisSam
  
})
names(Sams) <- samSpecs$IDSAM

```




[comment]: <> (> Direction goes from borrowers to lenders: an ``in'' arrow represents an asset of the node that arros points towards, as in Gai Kapadia 2010.)

> `r if_else(samSpecs$W.DIRECTED==TRUE, "**DIRECTED**", "**UN**-DIRECTED")` W.

> `r if_else(params$W_WEIGHTED==TRUE, "**WEIGHTED**", "**UN**-WEIGHTED")` W.

> Bank predictors are `r samSpecs$X.FROM`.

Using Martineeti & Geniaux (2017) approximation to the likelihood.

I considered failures till **`r mean(samSpecs$Y.FAILUREHORIZON)`**. 

Banks with no links are included? `r samSpecs$W.ALLOW.ZERO `


# LOAD SAMPLES

I reescaled the following vars

`r print(cols)` . These vars are in percentage points in the Stata DB. I divide these values by 100 giving then ratios, ie 0.08 instead of 8.

Samples are:

```{r}
datatable(samSpecs)
```

# DESC STATS

## Bank covariates

```{r descStatsBankCovariates}
#(#| results: asis)
walk2(Sams, names(Sams), function(thisSam, idSam) {
  list2env(thisSam, envir = environment())
  # old samples don'thave samBanks
  if(exists('samBanks', where=thisSam)) {
    descStatsT <- dplyr::bind_cols('y'=y, X, 'IDENT'=samBanks$IDENT) %>%
      descStats2(.)
  } else {
    descStatsT <- dplyr::bind_cols('y'=y, X, 'IDENT'=0) %>%
      descStats2(.)
  }
  
  cat('### ', idSam, '\n\n')
  DT::datatable(descStatsT) %>%
        formatRound(columns=c('min', 'median', 'mean', 'SD', 'max', 'CV'))
  
  #knitr::knit_print({DT::datatable(descStatsT) %>%
  #      formatRound(columns=c('min', 'median', 'mean', 'SD', 'max', 'CV'))})
  
  #cat('\n\n')

  
})

```


## Networks

::: panel-tabset
```{r descStatsNetworks}
# #| results: asis

walk2(Sams, names(Sams), function(thisSam, idSam) {
  
  cat('### ', idSam, '\n\n')
  
  # Summary statitcis network
  print(summary(spdep::mat2listw(thisSam$W), 
                zero.policy=filter(samSpecs, IDSAM == idSam)$W.ALLOW.ZERO))
  cat('\n\n')
  
  plot(thisSam$G, edge.label = E(thisSam$G)$weight)
  
})

```
:::



# ESTIMATION

```{r}
R <- list() # store results

modelFormula <- y ~ log(ActivoN) + 
                       CAR_IRR_3A6 + P_LOANS_ARS_RATE_W +  APRSpNF_RATE_W + APR_USD_RATE + APR_RATE_W +
                       C8Est_w + P_ROA + P_DEP_ARS_RATE
# For output tables SPATIAL MODELS
coefNamesMap <- list("(Intercept)" = 'Intercept',
                    'log(ActivoN)' = 'ln(Assets)',
                     'CAR_IRR_3A6' = 'Non-performing loans',
                     'P_LOANS_ARS_RATE_W' = 'Loans interest rate',
                     'APRSpNF_RATE_W' = 'Govt. loans to Loans',
                     'APR_USD_RATE' = 'USD loans to Loans',
                     'APR_RATE_W' = 'Loans-to-Assets ratio',
                     'C8Est_w' = 'Equity-to-Assets ratio',
                     'P_ROA' = 'ROA',
                     'P_DEP_ARS_RATE' = 'Deposits interest rate',
                     'rho' = 'rho',
                    'lambda' = 'rho')
tabSpecs <- list('custom.coef.map' = coefNamesMap,
                 'stars' = c(0.01, 0.05, 0.10, 0.15),
                  'siunit' = TRUE,
                 'digits' = 2,
                 'booktabs' = TRUE,
                 'groups' = list("\\textbf{Size}" = 1:2,
                               "\\textbf{Asset-side risk}" = 3:7,
                               "\\textbf{Funding}" = 8:10,
                               "\\textbf{Spatial}" = 11),
                 'useCovar' = params$PSAR_COVAR) # how std error for probtiSAR should be computed? 

# For output tables NON-SPATIAL MODELS (Probit)
coefNamesNonSp <- c(NA, 'ln(Assets)', 
      'Non-performing loans', 'Loans interest rate', 'Govt. loans to Loans', 'USD loans to Loans', 'Loans-to-Assets ratio',
       'Equity-asset ratio', 'ROA', 'Deposits interest rate')
tabSpecsNonSp <- list('custom.coef.names' = coefNamesNonSp,
                 'stars' = c(0.05, 0.10, 0.15),
                  'siunit' = TRUE,
                 'digits' = 2,
                 'booktabs' = TRUE,
                 'groups' = list("Size" = 1:2,
                               "Asset-side risk" = 3:7,
                               "Funding" = 8:10))

```

The model is `r print(modelFormula)`



::: panel-tabset


:::

## LPM

```{r LPM}
R[['LPM']] <- map2(Sams, names(Sams), function(thisSam, samID) {
  list2env(thisSam, envir = environment())
  
  # TODO: You probably want to have all the vars in the regression
  LPMEst <- lm(formula = modelFormula,
    data = bind_cols('y'=y, X))
  
  LPMHat <- summary(LPMEst)
  # Modify std errors
  LPMHat$coefficients <- coeftest(LPMEst, 
                                  vcov=vcovHC(LPMEst, omega=NULL, type='HC3'))
  
})
names(R$LPM) <- names(Sams)

```


## Linear SAR robust hetero

```{r estimation_sar_het}
R[['SARHet']] <- map2(Sams, names(Sams), function(thisSam, samID) {
  
  list2env(thisSam, envir = environment())
  
  # TODO: You probably want to have all the vars in the regression
  sphet::spreg(formula = modelFormula,
    data = bind_cols('y'=y, X),
    listw = Matrix(W, sparse=TRUE),
    model = 'lag',
    het = TRUE) 

  
})
names(R$SARHet) <- names(Sams)

```

### Marginal effects
```{r}
R[['SARHetEffects']] <- map2(R$SARHet, names(R$SARHet), function(tM, modID) {
  #tM <- R$SARHet$A98_W98_B2L_nz_99FT01q3
  effects <- sphet::impacts(tM, 
                            listw = spdep::mat2listw(tM$listw),
                            R=1000) %>%
          summary(.)
  # You need to know N on each effect to compute pvals
  list('direct' = list('Coef' = effects$direct_sum, 'N' = length(tM$yhat)),
      'indirect' = list('Coef'= effects$indirect_sum, 'N' = length(tM$yhat)),
        'total' = list('Coef' = effects$total_sum, 'N' = length(tM$yhat)) )
  
  
})
names(R$SARHetEffects) <- names(R$SARHet)
# See documentation for impacts.stsls_sphet()
```



### Failure till 2001

#### W unrestricted

```{r}
#theseModels <- c('A99_W99_creWu_b97q4_s01q4','A99_W00_creWs_b97q4_s01q4', 'A99_W00_creWu_b97q4_s01q4')
# No rest on W as in baseline

theseModels <- tibble('IDSAM' = c('A98_W97_B2L_nz_99FT01q3',
'A98_W98_B2L_nz_99FT01q3',
'A98_W99t01q3NoRest_B2L_nz_99FT01')) %>%
  left_join(., samSpecs[, c('IDSAM', 'DESC')], by='IDSAM')

modNamesLong <- str_c(theseModels$IDSAM, theseModels$DESC, sep=" - ")


do.call(texreg, c('l'=list(R$SARHet[theseModels$IDSAM]),
                  'custom.model.names' = list(modNamesLong),
  'caption'= list("Linear SAR results. "),
                  tabSpecs)) %>%
  # You don't need math mode in siunitx
  gsub("^{*", "*", ., fixed=TRUE) %>%
  gsub("*}", "*   ", ., fixed=TRUE) %>%
  gsub("^{\\cdot} ", "\\str{\\cdot}", ., fixed=TRUE) %>%
  gsub("} & {", "}\n & {", ., fixed=TRUE)

```

#### W restricted

```{r}
#theseModels <- c('A99_W99_creWu_b97q4_s01q4','A99_W00_creWs_b97q4_s01q4', 'A99_W00_creWu_b97q4_s01q4')

theseModels <- tibble('IDSAM' = c('A98_W97rest_B2L_nz_99FT01q3',
'A98_W98rest_B2L_nz_99FT01q3',
'A98_W99t01q3_B2L_nz_99FT01')) %>%
  left_join(., samSpecs[, c('IDSAM', 'DESC')], by='IDSAM')

modNamesLong <- str_c(theseModels$IDSAM, theseModels$DESC, sep=" - ")


do.call(texreg, c('l'=list(R$SARHet[theseModels$IDSAM]),
                  'custom.model.names' = list(modNamesLong),
  'caption'= list("Linear SAR results. "),
                  tabSpecs)) %>%
  # You don't need math mode in siunitx
  gsub("^{*", "*", ., fixed=TRUE) %>%
  gsub("*}", "*   ", ., fixed=TRUE) %>%
  gsub("^{\\cdot} ", "\\str{\\cdot}", ., fixed=TRUE) %>%
  gsub("} & {", "}\n & {", ., fixed=TRUE)

```

### Failure till 2003

```{r}
#| eval: true
theseModels <- tibble('IDSAM' = c('A98_W97_B2L_nz_99FT03q4',
'A98_W98_B2L_nz_99FT03q4',
'A98_W99t01q3NoRest_B2L_nz_99FT03',
'A98_W97rest_B2L_nz_99FT03q4',
'A98_W98rest_B2L_nz_99FT03q4',
'A98_W99t01q3_B2L_nz_99FT03')) %>%
  left_join(., samSpecs[, c('IDSAM', 'DESC')], by='IDSAM')

modNamesLong <- str_c(theseModels$IDSAM, theseModels$DESC, sep=" - ")


do.call(texreg, c('l'=list(R$SARHet[theseModels$IDSAM]),
                  'custom.model.names' = list(modNamesLong),
  'caption'= list("Linear SAR results. "),
                  tabSpecs)) %>%
  # You don't need math mode in siunitx
  gsub("^{*", "*", ., fixed=TRUE) %>%
  gsub("*}", "*   ", ., fixed=TRUE) %>%
  gsub("^{\\cdot} ", "\\str{\\cdot}", ., fixed=TRUE) %>%
  gsub("} & {", "}\n & {", ., fixed=TRUE)

```

#### Marginal effects (robust hetero)

```{r sar_het_mg_eff_compute}
SARmgEffHet <- map2(R$SARHet, Sams, function(thisModel, thisSam) {
   
  out = sphet::impacts(thisModel, listw=spdep::mat2listw(thisSam$W))
  t = tibble("Coefficient" = unlist(coefNamesMap)[2:(length(coefNamesMap)-2)],
           "Direct" = out$direct, 
          "Indirect" = out$indirect, 
          "Total" = out$total)
  t
  
})
names(SARmgEffHet) <- names(Sams)
```


```{r sar_het_mg_eff_table}
theseModels <- names(SARmgEffHet)
modNamesLong = filter(samSpecs, IDSAM %in% theseModels) %>%
  select(IDSAM, DESC)
modNamesLong <- str_c(modNamesLong$IDSAM, modNamesLong$DESC, sep=" - ")

walk2(SARmgEffHet, modNamesLong, function(thisEff, modelName) {
  cat(paste0("\n", modelName, "\n"))
  thisEff %>%
    mutate(across(Direct:Total, ~ round(.x, digits=3))) %>%
    df_2_latex(.)
  
})
```

END LINEAR SAR RESULTS

## Probit

Fit a non-spatial probit

```{r estimation_probit}

# Estimate and compue marginal effects and their std errors
Probits <- map2(Sams, names(Sams), function(thisSam, thisSamName) {
  #thisSam <- 'A98_W97_B2L_nz_99FT03q4'
  list2env(thisSam, envir = environment())
  
  theEst <- probitmfx(formula = modelFormula,
            data = bind_cols('y'=y, X),
            atmean = FALSE)
  
  R[['probit']][[thisSamName]] <<- theEst$fit # the glm object
  R[['probitEffects']][[thisSamName]] <<- theEst$mfxest # the mg effects
  
})

coefNamesNonSp <- c(NA, 'ln(Assets)', 
      'Non-performing loans', 'Loans interest rate', 'Govt. loans to Loans', 'USD loans to Loans', 'Loans-to-Assets ratio',
       'Capital-asset ratio', 'ROA', 'Deposits interest rate')

```


```{r probit_coef}

theseModels <- tibble('IDSAM' = c('A98_W97_B2L_nz_99FT01q3',
                                  'A98_W98_B2L_nz_99FT01q3',
                                  'A98_W99t01q3NoRest_B2L_nz_99FT01')) %>%
  left_join(., samSpecs[, c('IDSAM', 'DESC')], by='IDSAM')

modNamesLong <- str_c(theseModels$IDSAM, theseModels$DESC, sep=" - ")

# Strict W
do.call(screenreg, c('l'=list(R$probit[theseModels$IDSAM]),
                  'custom.model.names' = list(modNamesLong),
  'caption'= list("PROBIT SAR results. "),
                  tabSpecsNonSp))
```

### Mg effects

```{r probit_mg_eff}
txRegs <- map(R$probitEffects[theseModels$IDSAM], function(Mfxest) {
  createTexreg(
    coef.names = rownames(Mfxest),
    coef = Mfxest[, 1],
    se = Mfxest[, 2],
    pvalues = Mfxest[, 4]  )
})
texreg(txRegs)
    

```


```{r compute_probit_mg_effects}
#| eval: false
R[['probitEffects']] <- map2(R$probit, names(R$probit), function(r, samName) {
  
pMarginals <- dnorm( r$x %*% r$coefficients )
  #r =R$probit[[3]]  
  pSummary <- summary.glm(r)
  
  # Marginal effect of the average bank
  x_Bar <- apply(r$x, MARGIN=2, mean) # Kx1 vector
  pMarginalAvgBank <- dnorm( t(x_Bar) %*% r$coefficients)
  
  pmap_dfr(as_tibble( pSummary$coefficients, rownames='var'), 
           function(var, Estimate, `Std. Error`, ...) { 
  # CAMERON TRIVEDIR p467. Avergae Marginal effect of variable j is the average (over observations) of pdf(X Beta) * \hat{\beta}_j
    tibble('n' = NROW(r$y),
           'var' = var, 
           'avgEffectMean' = mean(pMarginals * Estimate),
           'avgEffectMin90' = avgEffectMean - 1.645 * (`Std. Error`)*(1/sqrt( n )), 
           'avgEffectMax90' = avgEffectMean + 1.645 * (`Std. Error`)*(1/sqrt( n )),
           'effectAvgBankMean' = pMarginalAvgBank * Estimate,
           'effectAvgBankMin90' = effectAvgBankMean - 1.645* (`Std. Error`)*(1/sqrt( n )),
           'effectAvgBankMax90' = effectAvgBankMean + 1.645*(`Std. Error`)*(1/sqrt( n )))
  }) 
  
})
```


## SAR Probit

```{r estimation_probit_sar}
R$SARProbit <- map(Sams, function(thisSam) {
  list2env(thisSam, envir = environment())
  print(paste0(specs$IDSAM, "\n"))
  
  ProbitSpatial::ProbitSpatialFit(formula = modelFormula,
    data = bind_cols('y'=y, X),
    W = Matrix(W, sparse=TRUE),
    method = 'full-lik')
  
  #PSfit2(formula = modelFormula,
  #  data = bind_cols('y'=y, X),
  #  W = Matrix(W, sparse=TRUE),
  #  method = 'full-lik')
  
})
names(R$SARProbit) <- names(Sams)
```

#### Failure till 2001

##### W unrestricted

```{r}
#theseModels <- c('A99_W99_creWu_b97q4_s01q4','A99_W00_creWs_b97q4_s01q4', 'A99_W00_creWu_b97q4_s01q4')
#theseModels <- samIDs
theseModels <- tibble('IDSAM' = c('A98_W97_B2L_nz_99FT01q3',
'A98_W98_B2L_nz_99FT01q3',
'A98_W99t01q3NoRest_B2L_nz_99FT01')) %>%
  left_join(., samSpecs[, c('IDSAM', 'DESC')], by='IDSAM')

modNamesLong <- str_c(theseModels$IDSAM, theseModels$DESC, sep=" - ")

# Strict W
do.call(texreg, c('l'=list(R$SARProbit[theseModels$IDSAM]),
                  'custom.model.names' = list(modNamesLong),
  'caption'= list("PROBIT SAR results. "),
                  tabSpecs)) %>%
  # You don't need math mode in siunitx
  gsub("^{*", "*", ., fixed=TRUE) %>%
  gsub("*}", "*   ", ., fixed=TRUE) %>%
  gsub("^{\\cdot} ", "\\str{\\cdot}", ., fixed=TRUE) %>%
  gsub("} & {", "}\n & {", ., fixed=TRUE)

```

##### W restricted


```{r}
#theseModels <- c('A99_W99_creWu_b97q4_s01q4','A99_W00_creWs_b97q4_s01q4', 'A99_W00_creWu_b97q4_s01q4')
#theseModels <- samIDs

theseModels <- tibble('IDSAM' = c('A98_W97rest_B2L_nz_99FT01q3',
'A98_W98rest_B2L_nz_99FT01q3',
'A98_W99t01q3_B2L_nz_99FT01')) %>%
  left_join(., samSpecs[, c('IDSAM', 'DESC')], by='IDSAM')

modNamesLong <- str_c(theseModels$IDSAM, theseModels$DESC, sep=" - ")
# Strict W
do.call(texreg, c('l'=list(R$SARProbit[theseModels$IDSAM]),
                  'custom.model.names' = list(modNamesLong),
  'caption'= list("PROBIT SAR results. "),
                  tabSpecs)) %>%
  # You don't need math mode in siunitx
  gsub("^{*", "*", ., fixed=TRUE) %>%
  gsub("*}", "*   ", ., fixed=TRUE) %>%
  gsub("^{\\cdot} ", "\\str{\\cdot}", ., fixed=TRUE) %>%
  gsub("} & {", "}\n & {", ., fixed=TRUE)

```


<!-- #### Failure till 2003 -->

<!--  ##### W unrestricted -->

```{r}
#| eval: false
#theseModels <- samIDs

theseModels <- tibble('IDSAM' = c('A98_W97_B2L_nz_99FT03q4',
'A98_W98_B2L_nz_99FT03q4',
'A98_W99t01q3NoRest_B2L_nz_99FT03')) %>%
  left_join(., samSpecs[, c('IDSAM', 'DESC')], by='IDSAM')

modNamesLong <- str_c(theseModels$IDSAM, theseModels$DESC, sep=" - ")

# Strict W
do.call(texreg, c('l'=list(R$SARProbit[theseModels$IDSAM]),
                  'custom.model.names' = list(modNamesLong),
  'caption'= list("PROBIT SAR results. "),
                  tabSpecs)) %>%
  gsub("^{*", "*", ., fixed=TRUE) %>%
  gsub("*}", "*   ", ., fixed=TRUE) %>%
  gsub("^{\\cdot} ", "\\str{\\cdot}", ., fixed=TRUE) %>%
  gsub("} & {", "}\n & {", ., fixed=TRUE)

```

<!-- ##### W restricted -->

```{r}
#theseModels <- samIDs

theseModels <- tibble('IDSAM' = c('A98_W97rest_B2L_nz_99FT03q4',
'A98_W98rest_B2L_nz_99FT03q4',
'A98_W99t01q3_B2L_nz_99FT03')) %>%
  left_join(., samSpecs[, c('IDSAM', 'DESC')], by='IDSAM')

modNamesLong <- str_c(theseModels$IDSAM, theseModels$DESC, sep=" - ")

# Strict W
do.call(texreg, c('l'=list(R$SARProbit[theseModels$IDSAM]),
                  'custom.model.names' = list(modNamesLong),
  'caption'= list("PROBIT SAR results. "),
                  tabSpecs)) %>%
  gsub("^{*", "*", ., fixed=TRUE) %>%
  gsub("*}", "*   ", ., fixed=TRUE) %>%
  gsub("^{\\cdot} ", "\\str{\\cdot}", ., fixed=TRUE) %>%
  gsub("} & {", "}\n & {", ., fixed=TRUE)

```

::: panel-tabset


##### W unweighted and directed (asymmetric W)

```{r}

tSams <- list('A98_W98unw_B2L_nz_99FT01q3' = '$\bar{W}_{98; Unw}$',
              'A98_W97_B2L_nz_99FT01q3' =  '$\bar{W}_{97}$',
              'A98_W99t01q3NoRest_B2L_nz_99FT01' =  '$\bar{W}_{99-01}$',
              'A98_W98und_B2L_nz_99FT01q3' = '$\bar{W}_{98, Unw, S}$',
              'A98_W97und_B2L_nz_99FT01q3' = '$\bar{W}_{97; Unw,S}$',
              'A98_W99t01q3und_B2L_nz_99FT01q3' = '$\bar{W}_{99-01; Unw,S}$')

# Omit the first one since it was estimated above
map(as.list(names(tSams)[-(1)]), function(samName) {
  list2env(Sams[[samName]], envir = environment())

  
  R$SARProbit[[samName]] <<- ProbitSpatial::ProbitSpatialFit(formula = modelFormula,
    data = bind_cols('y'=y, X),
    W = Matrix(W, sparse=TRUE), 
    method = 'full-lik')
  
})
```

Table
```{r}

do.call(texreg, c('l'=list(R$SARProbit[names(tSams)]),
                  #'custom.model.names' = flatten(tSams),
                  'caption'= list("PROBIT SAR results. "),
                  tabSpecs)) %>%
  gsub("^{*", "*", ., fixed=TRUE) %>%
  gsub("*}", "*   ", ., fixed=TRUE) %>%
  gsub("^{\\cdot} ", "\\str{\\cdot}", ., fixed=TRUE) %>%
  gsub("} & {", "}\n & {", ., fixed=TRUE)
```

#### Marginal effects

```{r}
R$SARprobitMgEff <- map2(R$SARProbit, Sams, function(thisModel, thisSam) {
  #thisModel = R$SARProbit[[2]]
  #thisSam <- Sams[[2]]
  
  ProbitSpatial::effects_ProbitSpatial(thisModel) %>%
    as_tibble(., rownames = 'predictor')
    #rename(Direct = direct, Indirect = indirect, Total = total) %>%
    #mutate(Predictor = unlist(coefNamesMap)[2:(length(coefNamesMap)-2)])
  
  
})
names(R$SARprobitMgEff) <- names(Sams)
```


```{r}
theseModels <- names(R$SARprobitMgEff)
modNamesLong = filter(samSpecs, IDSAM %in% theseModels) %>%
  select(IDSAM, DESC)
modNamesLong <- str_c(modNamesLong$IDSAM, modNamesLong$DESC, sep=" - ")
# for each model there are 3 'submodels' : direct, ind and total
#txRegs <- map(theseModels$IDSAM, ), createTexreg(coef.names = .$predictor,
#                                       coef = .$direct))
#screenreg(list(createTexreg(coef.names = R$SARprobitMgEff[[theseModels$IDSAM]]$predictor,
#                                        coef = R$SARprobitMgEff[[theseModels]]$direct)
#texRegs$SARProbitIndirect <- createTexreg(coef.names = R$SARprobitMgEff[[samName]]$predictor,
#                                        coef = R$SARprobitMgEff[[samName]]$indirect)
#texRegs$SARProbitTotal <- createTexreg(coef.names = R$SARprobitMgEff[[samName]]$predictor,
#                                        coef = R$SARprobitMgEff[[samName]]$total)
#))
```
:::


## SAVE RESULTS (WiP)

```{r save_model_objs}
#Save Results
saveRDS(R, 
        file=paste0('../../_model.rds'))
```

```{r }
#| eval: false
as_hux(descStatsT) %>% quick_xlsx(paste0(specs$savingFolder, 'desc_stats_table.xlsx'))

saveRDS(model, file=paste0(specs$savingFolder, specs$idSample, '_model.rds'))

rhoZvalue <- (regSumm$rho / regSumm$rho.se) %>% abs()
rhoPvalue = (1-pnorm(rhoZvalue))*2

#outList <- list(NULL)
#names(outList) <- specs$idSample
estimatesTibble <- as_tibble(regSumm$Coef) %>%
  rename('EST_COEF' = 'Estimate',
         'STD_ERROR' ='Std. Error',
         'Z_VALUE' ='z value',
         'P_VALUE' = 'Pr(>|z|)') %>%
  mutate('ID_SAMPLE' = specs$idSample,
    'PREDICTOR' = rownames(regSumm$Coef), .before=1) %>%
  add_row(ID_SAMPLE = specs$idSample, PREDICTOR='rho', 
          EST_COEF = regSumm$rho, STD_ERROR = regSumm$rho.se,  Z_VALUE = rhoZvalue, 
          P_VALUE = rhoPvalue) %>%
  mutate('MODEL_LOG_LIK_LM' = regSumm$logLik_lm.model,
         'MODEL_N' = NROW(regSumm$fitted.values),
         'WALD_TEST_SDEPENDANCE_PVALUE' = regSumm$Wald1$p.value,
         'LR_TEST_SDEPENDANCE_PVALUE' = regSumm$LR1$p.value)

write_excel_csv(estimatesTibble, file = paste0('C:/Users/emi.ABLE-22868/OneDrive/UWA PhD/bankFailure/output/results_main.csv'),
                append=TRUE)
```

## MISC

```{r}
print(samIDs)
```

**EOF**

```{r}
#| eval: false
knitr::knit_exit()
```

