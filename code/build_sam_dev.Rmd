---
author: "Emi"
params:
  IDSAM: "A99_W00_creWs_b97q4_s03q4"
output: 
  html_document:
    code_folding: hide
    number_sections: true
    self_contained: true
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(tsibble) # Panel data/longitudinal
library(haven) # Access to Stata databases
library(tidygraph) # Plotting graphs
library("igraph", quietly = TRUE, warn.conflicts = FALSE, verbose = FALSE)
require(visNetwork)
library(writexl)
library(svglite) # export plots to svg
library(rmatio) # expor to Matlab
library(spdep)
library(spatialreg)
library(huxtable) # export tables (tibble) to Latex/Excel
source('Rutils/Emi_R_utils.R')
source('BAFA_funs.R')

```

```{=html}
<style type="text/css">
  .main-container {
    max-width: 1100px;
    margin-left: auto;
    margin-right: auto;
  }
</style>
```

# Sample specs

```{r sample_specs}
# RUN THIS BEFORE KNITTING!!!
# Sam Specs
SS <- read_csv('../Data/sams_specs_BAFA.csv', show_col_types = FALSE) %>% filter(IDSAM == params$IDSAM)
if(NROW(SS) > 1) { stop(paste0("The provided SAMID, ", IDSAM, " is NOT unique!")) }
if(NROW(SS) == 0) { stop(paste0("The provided SAMID, ", IDSAM, " cant be found!")) }

```

---
  title: `r SS$IDSAM`
  date: `r today()`
---

## Output
The vector $\mathbf{a}$ which contains the failure time for each bank in the whole sample.
`data(t).X`

The covariates for each bank at each $t$

`W`
It is the fixed network. 
  
-   Only banks that were alive by `r SS$X.BANKBIRTHFROM`

-   $\mathbf{y}_t$ is 1 if the bank fails between `r SS$Y.FAILURESINCE` and `r SS$Y.FAILUREHORIZON`.

-   $W$ is the average between the beginning of data (around 1997q3) and `r SS$W.TO`. Hence we use past information about the network. The network only contains entities that lend during the period. All lender in a directed graph.

-   $X$ is data from `r SS$X.FROM` to `r SS$X.TO`.

# LOAD DATA

## Bank covariates

```{r load_bank_data}
banksDB <- haven::read_dta('../data/BAFAannual/failures-1997-2001-annual.dta') %>%
  dplyr::mutate(., 
        fechaQ = quarter(as_date(FECHA_D, origin=ymd('1960-01-01')), with_year=TRUE),
        exitDateQ = quarter(as_date(EXIT_DATE, origin=ymd('1960-01-01')), with_year=TRUE),
        startDateQ = quarter(as_date(FIRST_DATE, origin=ymd('1960-01-01')), with_year=TRUE),
        .after = IDENT) 
  
banks <- banksDB %>%
  drop_na %>%
  filter(FECHA_A == SS$X.FROM) %>%
  # ONly private banks
  filter(GRUPO_ID_UNI != 4 & GRUPO_ID_UNI !=5) %>%
  filter(startDateQ<= !!SS$X.BANKBIRTHFROM & exitDateQ >= !!SS$Y.FAILURESINCE)
  # these 3 banks have no links
  #filter(!(IDENT %in% c(45056, 45118, 64025)))

# Select only entities private and alive on 1997q4
banksAtStart <- banksDB %>%
dplyr::group_by(IDENT) %>%
  summarise('start' = FECHA_A,
            'startDateQ' = min(startDateQ),
            NOMRED = first(NOMRED),
            GRUPO_ID_UNI = first(GRUPO_ID_UNI),
            P_LOANS_ARS_RATE_W = first(P_LOANS_ARS_RATE_W))

excBanks <- filter(banksDB, startDateQ>1997.4) %>% 
   summarise(IDENT = min(IDENT), NOMRED = first(NOMRED))

```


I lose ```r NROW(excBanks)``` banks because a) they don't have complete observations by 1997.4 (missing P_LOANS_ARS_RATE) or b) they were privatised after 1997q4.

```{r}
select(excBanks, NOMRED, IDENT)
```

Hence I end up with `r banks$IDENT %>% unique() %>% NROW()` banks.

## Network data

```{r load_network_data}
dbRelations <- read_dta('../data/interLoans/cen_deu_1997-06_2001_quarterly.dta') %>%
  mutate(FECHA_Q = ( as_date(FECHA_D, origin=ymd("1960-01-01")) %>% 
                     tsibble::yearquarter(.) ),
         weight = .data[[ SS$W.WVAR]]*100) %>%
  tsibble(key = c(IDENT_ACREEDORA, IDENT_DEUDORA), 
          index = FECHA_Q)
# igraph needs weight in lower case

# W_A_PR W_D_PR
thisRelations <- filter_index(dbRelations, SS$W.FROM ~ SS$W.TO) %>%
  # fechaQ >= 1997.4 &
  filter(., (IDENT_ACREEDORA != IDENT_DEUDORA)) %>%
  filter(., weight != 0 & !is.na(weight))
       
head(thisRelations)

# Number of unique relations (links)
uLinksN <- select(thisRelations, IDENT_ACREEDORA, IDENT_DEUDORA) %>%
  distinct() %>%
  nrow()

```

There are `r uLinksN` unique links (edges) in the original `thisRelations` network.

# BUILD OBJECTS

## Build the Average Network

$W$ is the average for each link between `r SS$W.FROM` and `r SS$W.TO` for all banks

```{r}
# Reconvert to tibble because tsibble cannot drop the groupping by time (index)
avgRelations <- thisRelations %>%
  as_tibble(.) %>%
  group_by(IDENT_ACREEDORA, IDENT_DEUDORA) %>%
  summarise(weight = mean(weight)) %>%
  # W can only contains entities that are in the sample. 
  # So both, IDENT_ACREEDORA and IDENT_DEUDORA must refer to IDENT that are in banks
  semi_join(., select(banks, IDENT),  by= c('IDENT_ACREEDORA' = 'IDENT')) %>%
  semi_join(., select(banks, IDENT),  by= c('IDENT_DEUDORA' = 'IDENT')) 
  #filter(., weight<0.1)
# This dataframe should be empty
netExcBanks <- bind_rows(anti_join(avgRelations, banks, by=c('IDENT_ACREEDORA' = 'IDENT')),
                    anti_join(avgRelations, banks, by=c('IDENT_DEUDORA' = 'IDENT')))

head(avgRelations)

uLinksN <- select(avgRelations, IDENT_ACREEDORA, IDENT_DEUDORA) %>%
  distinct() %>%
  nrow()

```

There are `r uLinksN` unique links in the average network `avgRelations`.

You dont want to have a row of zeros (an entitiy with no relationship). If the graph is **directed** based on lender that means that all entities that do not lend should not be in the graph and this in the analysis. If the graph is **undirected** it does not matter.

```{r}
thisVars <- str_split(SS$X.VARS, ", ", simplify=TRUE)[1,] %>%
  str_trim(., side='both')
X <- banks %>% select(all_of(thisVars))

# 1: failure, 0: survival during the sample period
y <- if_else(banks$exitDateQ <= SS$Y.FAILUREHORIZON, 1, 0)

samRelations <- 
  if(SS$W.WVAR == "W_A_PR") {
    # lender perspective
    samRelations <- select(avgRelations, IDENT_ACREEDORA, IDENT_DEUDORA, weight)
  } else if (SS$W.WVAR == "W_D_PR") {
    # borrower perspective
    samRelations <- select(avgRelations, IDENT_DEUDORA, IDENT_ACREEDORA, weight)
  }

nodes <- banks %>%
  select(., IDENT, NOMRED, ActivoN) %>%
  mutate(survival = y)

network <- igraph::graph_from_data_frame(d = samRelations, 
                           vertices = nodes,
                          directed = if_else((SS$W.WVAR == ''), FALSE, TRUE))

summary(network)
# FOR DIRECTED GRAPH
if (is.directed(network)){
  # Delete isolated nodes
  # I prune the graph until all nodes are connected
  Gd <- network
  edgeMode <- 'out' # out for directed graph
  isolated = which(degree(Gd, mode=edgeMode)==0)
  excBanks <- isolated
  while (length(isolated)>0) {
    Gd = delete.vertices(Gd, isolated)
    excBanks <- c(excBanks, isolated)
    
    isolated = which(degree(Gd, mode=edgeMode)==0)
  }
}

summary(Gd)
summary(network)

Wstd <- create_adj_matrix(network)
spatialRegNetwork <-  spdep::mat2listw(Wstd) 
summary(spatialRegNetwork, zero.policy=TRUE)

WdStd <- create_adj_matrix(Gd)
spatialRegGd <-  spdep::mat2listw(WdStd) 
summary(spatialRegGd, zero.policy=FALSE)

```

Identify lenders and borrowers
```{r lenders_and_borrowers}
borrowers <- unique(avgRelations$IDENT_DEUDORA)
lenders <- unique(avgRelations$IDENT_ACREEDORA)
banks <- mutate(banks, 'IS_BORROWER' = (IDENT %in% borrowers),
                            'IS_LENDER' = (IDENT %in% lenders))
# The borrower is also a lender
strictLenders <- filter(avgRelations,
                        IDENT_DEUDORA %in% lenders)$IDENT_ACREEDORA %>%
  unique()
# The lender is also a borrower
strictBorrowers <- filter(avgRelations,
                        IDENT_ACREEDORA %in% borrowers)$IDENT_DEUDORA %>%
  unique()
    
```

Filter network: restrict to only lenders, only borrowers or both. 

```{r filter_network}
if (SS$W.WVAR == '') {
  #
  # UNDIRECTED GRAPH
  #
  print('Graph is UNDIRECTED')
  samBanks = banks
  samRelations = select(avgRelations, c(IDENT_DEUDORA, IDENT_ACREEDORA)) # no need to exclude banks not arleady excluded above; don't need the weight column
  excBanks <- tibble()
  
} else 
{
  #
  # DIRECTED GRAPH
  #
  # Retain banks that appear in the network
  if (SS$W.WVAR == "W_A_PR") {
    # LENDER PERSPECTIVE (banks that don't lend are excluded)
    #All relations in the network have to have units that are both lenders
      # The current problem is a bank (45072) that lends but only to a bank that is not in the network (45118) in included. Bank 45072 should not be included.
    print('Graph is DIRECTED weighted from lenders perspective. Only lender banks.')
    # borrowers that are lenders
    if (SS$W.STRICT == TRUE) {
      # if STRICT, I also exclude banks that dont borrow
      print("W is strict, so banks that don't borrow are also excluded")
      samRelations <- avgRelations %>%
        # W can only contains entities that are in the NEW sample samBanks. 
        # and only lenders
        filter(., (IDENT_ACREEDORA %in% strictLenders) & (IDENT_DEUDORA %in% strictLenders)) %>%
        select(., IDENT_ACREEDORA, IDENT_DEUDORA, weight)
        incBanks <- unique(samRelations$IDENT_ACREEDORA) # borrowers are not needed here since we only care about lenders
      
      # UPdate samBanks
      samBanks <- filter(banks,  IDENT %in% incBanks)
      
    } else
    {
      print("W is NOT strict, so borrowers don't need to be lenders themselves")
      samBanks <- banks
      samRelations <- avgRelations %>%
        select(., IDENT_ACREEDORA, IDENT_DEUDORA, weight)
    }
  }  
  else   
  {
    # DEBTOR PERSPECTIVE (banks that don't borrow are excluded)
    print('Graph is DIRECTED weighted from borrowers perspective')
    # if STRICT, I also exclude banks that dont borrow
    if (SS$W.STRICT == TRUE) {
      samRelations <- avgRelations %>%
      # W can only contains entities that are in the NEW sample samBanks. 
      # and only borrowers
      filter(., (IDENT_ACREEDORA %in% strictBorrowers) & (IDENT_DEUDORA %in% strictBorrowers)) %>%
      select(., IDENT_DEUDORA, IDENT_ACREEDORA, weight)
      incBanks <- unique(samRelations$IDENT_DEUDORA) # lenders are not needed here since we only care about borrowers
      
      # UPdate samBanks
      samBanks <- filter(banks,  IDENT %in% incBanks)
        
    } else {
      print("W is NOT strict, so lenders don't need to be borrowers themselves")
      samBanks <- banks
      samRelations <- avgRelations %>%
        select(., IDENT_DEUDORA, IDENT_ACREEDORA, weight)

    }
  }
}

samRelations
```

These banks are excluded because they don't borrow and/or lend.
```{r}
excBanks <- anti_join(banks, samBanks, by="IDENT") %>%
  select(NOMRED, IDENT, exitDateQ, IS_LENDER, IS_BORROWER)

excBanks %>%
  datatable(.)
```

```{r }
uLinksN <- select(samRelations, IDENT_ACREEDORA, IDENT_DEUDORA) %>%  distinct() %>%  nrow()
nLenders <- samRelations %>% ungroup() %>% summarise(n=n_distinct(IDENT_ACREEDORA)) %>% .$n
nBorrowers <- samRelations %>% ungroup() %>% summarise(n=n_distinct(IDENT_DEUDORA)) %>% .$n
nBanks <- samBanks %>% summarise(n=n_distinct(IDENT)) %>% .$n

```

I exclude `r NROW(excBanks)` because they are not debtors. Now I have a directed graph.

There are `r nLenders `  lenders, `r nBorrowers`  borrowers and `r uLinksN` unique linkes (edges) in the sample network (the final one). There are `r nBanks` entities in `samBank`.

## Build X and Y

Y is the failure vector, X the covariates vector

```{r X_Y}
thisVars <- str_split(SS$X.VARS, ", ", simplify=TRUE)[1,] %>%
  str_trim(., side='both')
X <- samBanks %>% select(all_of(thisVars))

# 1: failure, 0: survival during the sample period
y <- if_else(samBanks$exitDateQ <= SS$Y.FAILUREHORIZON, 1, 0)

```

Create a network (igraph) object and the spatial matrix `W` which only contains banks that are in `samBanks`

```{r }
nodes <- samBanks %>%
  select(., IDENT, NOMRED, ActivoN) %>%
  mutate(survival = y)
network <- igraph::graph_from_data_frame(d = samRelations, 
                           vertices = nodes,
                          directed = if_else((SS$W.WVAR == ''), FALSE, TRUE))

summary(network)
Wstd <- create_adj_matrix(network)

spatialRegNetwork <-  spdep::mat2listw(Wstd) 
```

There are `r nrow(samRelations)` links in `samRelations`; `r uLinksN` of them are unique. `Wstd` is `r nrow(Wstd)` $\times$ `r ncol(Wstd)` and the number of banks in `samBanks` is `r NROW(samBanks)`. They should be equal!


The following entities appear in the network but not in the banks dataframe: NROWS: `r NROW(netExcBanks)`. Should be empty!
Mean weight is `r mean(samRelations$weight)`


## Desc stats

### Banks

```{r descStatsBanks}
descStatsT <- dplyr::bind_cols('y'=y, X, 'IDENT'=samBanks$IDENT) %>%
  descStats2(.)

  descStatsT %>%
    datatable() %>%
    formatRound(columns=c('min', 'median', 'mean', 'SD', 'max', 'CV'))
```


### Network

```{r descStats_network}
summary(spatialRegNetwork, zero.policy=FALSE)
```


# Test a linear SAR
```{r estimation_sar}
model <- spatialreg::lagsarlm(formula ='y ~ log(ActivoN) + C8Est_w+ CAR_IRR_3A6+ P_ROA+ P_DEP_ARS_RATE +
  P_LOANS_ARS_RATE_W+ APRSpNF_RATE_W+ APR_USD_RATE+ APR_RATE_W',
        data = bind_cols('y'=y, X),
        listw = spatialRegNetwork,
        zero.policy = FALSE)

regSumm <- summary(model)

regSumm

```


# Save
## Sample
```{r sample_save}
fileName <- paste0('../', SS$SAMSAVINGFOLDER, SS$IDSAM, '.rds')

if (file.exists(fileName)) { 
  warning('the file already exists. I dont overwrite it')
} else {
  saveRDS(list('y'=y, 'X'=X, 'network'=network, 'Wstd'=Wstd, 
               'samBanks'=samBanks, 'specs'=SS), 
        file=fileName)
}

```
