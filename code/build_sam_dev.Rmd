---
author: "Emi"
params:
  IDSAM: 'A98_W98noNorm_B2L_nz_99FT01q3'
output: 
  html_document:
    code_folding: hide
    number_sections: true
    self_contained: true
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(tsibble) # Panel data/longitudinal
library(haven) # Access to Stata databases
library(tidygraph) # Plotting graphs
library("igraph", quietly = TRUE, warn.conflicts = FALSE, verbose = FALSE)
require(visNetwork)
library(readODS)
library(svglite) # export plots to svg
library(rmatio) # expor to Matlab
library(spdep)
library(spatialreg)
library(huxtable) # export tables (tibble) to Latex/Excel
library(summarytools)
source('Rutils/Emi_R_utils.R')
source('BAFA_funs.R')

```

```{=html}
<style type="text/css">
  .main-container {
    max-width: 1100px;
    margin-left: auto;
    margin-right: auto;
  }
</style>
```

# Sample specs

```{r sample_specs}
# RUN THIS BEFORE KNITTING!!!
# Sam Specs
SS <- read_ods('../Data/sams_specs_BAFA.ods') %>%
  filter(IDSAM == params$IDSAM)
#SS <- read_csv('../Data/sams_specs_BAFA.csv', show_col_types = FALSE) %>% filter(IDSAM == params$IDSAM)
if(NROW(SS) > 1) { stop(paste0("The provided SAMID, ", IDSAM, " is NOT unique!")) }
if(NROW(SS) == 0) { stop(paste0("The provided SAMID, ", IDSAM, " cant be found!")) }

thisVars <- str_split(SS$X.VARS, ", ", simplify=TRUE)[1,] %>%
  str_trim(., side='both')


```

---
  title: `r SS$IDSAM`
  date: `r today()`
---

## Specs
`W`
It is the fixed network. 
  
-   Only banks that were alive by `r SS$X.BANKBIRTHFROM`

-   $\mathbf{y}_t$ is 1 if the bank fails between `r SS$Y.FAILURESINCE` and `r SS$Y.FAILUREHORIZON`.

-   $W$ is the average between `r SS$W.FROM`  and `r SS$W.TO`. Hence we use past information about the network. The network only contains entities that lend during the period. All lender in a directed graph.

-   Is $W$ directed? `r SS$W.DIRECTED`

-   Is $W$ weighted? `r SS$W.WEIGHTED`

-   Is $W$ row-normalised? `r SS$W.ROW.NORM`

-   $X$ is data from `r SS$X.FROM` to `r SS$X.TO`.


## (Expected) Output
-   The vector $\mathbf{a}$ which contains the failure time for each bank in the whole sample.
-   Matrix $W$ which could be weighted (only 1 matrix as W)
`data(t).X`

The covariates for each bank at each $t$


# LOAD DATA

## Bank covariates

```{r load_bank_data}
banksDB <- haven::read_dta('../data/BAFAannual/BAFA-1997-2001-annual.dta') %>%
  dplyr::mutate(., 
        fechaQ = quarter(as_date(FECHA_D, origin=ymd('1960-01-01')), with_year=TRUE),
        exitDateQ = quarter(as_date(EXIT_DATE, origin=ymd('1960-01-01')), with_year=TRUE),
        startDateQ = quarter(as_date(FIRST_DATE, origin=ymd('1960-01-01')), with_year=TRUE),
        .after = IDENT) 
  
banks <- banksDB %>%
  mutate(failure = if_else(exitDateQ <= SS$Y.FAILUREHORIZON, 1, 0)) %>%
    drop_na(., any_of(c('failure', thisVars))) %>%
  filter(FECHA_A == SS$X.FROM) %>%
  # ONly private banks
  filter(GRUPO_ID_UNI != 4 & GRUPO_ID_UNI !=5) %>%
  filter(startDateQ<= !!SS$X.BANKBIRTHFROM & exitDateQ >= !!SS$Y.FAILURESINCE)

# Select only entities private and alive on 1997q4
banksAtStart <- banksDB %>%
dplyr::group_by(IDENT) %>%
  summarise('start' = FECHA_A,
            'startDateQ' = min(startDateQ),
            NOMRED = first(NOMRED),
            GRUPO_ID_UNI = first(GRUPO_ID_UNI),
            P_LOANS_ARS_RATE_W = first(P_LOANS_ARS_RATE_W))

excBanks <- filter(banksDB, startDateQ>1997.4) %>% 
   summarise(IDENT = min(IDENT), NOMRED = first(NOMRED))

```


I lose ```r NROW(excBanks)``` banks because a) they don't have complete observations by 1997.4 (missing P_LOANS_ARS_RATE) or b) they were privatised after 1997q4.

```{r}
select(excBanks, NOMRED, IDENT)
```

Hence I end up with `r banks$IDENT %>% unique() %>% NROW()` banks.

## Network data

```{r load_network_data}
dbRelations <- read_dta('../data/interLoans/cen_deu_1997-06_2001_quarterly.dta') %>%
  mutate(FECHA_Q = ( as_date(FECHA_D, origin=ymd("1960-01-01")) %>% 
                     tsibble::yearquarter(.) ),
         weight = .data[[ SS$W.WVAR]]*100) %>%
  tsibble(key = c(IDENT_ACREEDORA, IDENT_DEUDORA), 
          index = FECHA_Q)
# igraph needs weight in lower case

# W_A_PR W_D_PR
thisRelations <- filter_index(dbRelations, SS$W.FROM ~ SS$W.TO) %>%
  # fechaQ >= 1997.4 &
  filter(., (IDENT_ACREEDORA != IDENT_DEUDORA))
```

```{r net_desc_stat_b_filter}
descr(thisRelations$weight, round.digits=4)
hist(thisRelations$weight)
#, breaks=seq(from=0, to=30, by=0.05))
```

```{r net_filter_0}
thisRelations <- filter(thisRelations, weight > 0 & !is.na(weight))
if (!is.na(SS$W.LINK.WEIGHT.MIN)) {
  thisRelations <- filter(thisRelations, weight > SS$W.LINK.WEIGHT.MIN)
}
```


```{r net_after_filter}
descr(thisRelations$weight, round.digits = 4)
hist(thisRelations$weight)
#, breaks=seq(from=0, to=30, by=0.05))
head(thisRelations)

# Number of unique relations (links)
uLinksN <- select(thisRelations, IDENT_ACREEDORA, IDENT_DEUDORA) %>%
  distinct() %>%
  nrow()

```

There are `r uLinksN` unique links (edges) in the original `thisRelations` network.

# BUILD OBJECTS

I build the network first since it will determine which banks are included.

## Build the Average Network

$W$ is the average for each link between `r SS$W.FROM` and `r SS$W.TO` for all banks

```{r}
# Reconvert to tibble because tsibble cannot drop the groupping by time (index)
avgRelations <- thisRelations %>%
  as_tibble(.) %>%
  group_by(IDENT_ACREEDORA, IDENT_DEUDORA) %>%
  summarise(weight = mean(weight)) %>%
  # W can only contains entities that are in the sample. 
  # So both, IDENT_ACREEDORA and IDENT_DEUDORA must refer to IDENT that are in banks
  semi_join(., select(banks, IDENT),  by= c('IDENT_ACREEDORA' = 'IDENT')) %>%
  semi_join(., select(banks, IDENT),  by= c('IDENT_DEUDORA' = 'IDENT')) 
  #filter(., weight<0.1)
# This dataframe should be empty
netExcBanks <- bind_rows(anti_join(avgRelations, banks, by=c('IDENT_ACREEDORA' = 'IDENT')),
                    anti_join(avgRelations, banks, by=c('IDENT_DEUDORA' = 'IDENT')))

head(avgRelations)

uLinksN <- select(avgRelations, IDENT_ACREEDORA, IDENT_DEUDORA) %>%
  distinct() %>%
  nrow()

```

There are `r uLinksN` unique links in the average network `avgRelations`.

You dont want to have a row of zeros (an entitiy with no relationship). If the graph is **directed** based on lender that means that all entities that do not lend should not be in the graph and this in the analysis. If the graph is **undirected** it does not matter.

```{r igraph_network}
if(SS$W.DIRECTED == TRUE) {
  if(SS$W.WVAR == "W_A_PR") {
    # lender perspective
    #samRelations <- select(avgRelations, IDENT_ACREEDORA, IDENT_DEUDORA, weight)
    samRelations <- select(avgRelations, IDENT_DEUDORA, IDENT_ACREEDORA, weight)
  
  } else if (SS$W.WVAR == "W_D_PR") {
    # borrower perspective
    samRelations <- select(avgRelations, IDENT_ACREEDORA, IDENT_DEUDORA, weight)
  }
} else {
  # UNDIRECTED GRAPH, no weight
  samRelations <- select(avgRelations, IDENT_DEUDORA, IDENT_ACREEDORA)
}

nodes <- banks %>%
  select(., IDENT, NOMRED, ActivoN, failure)
  
network <- igraph::graph_from_data_frame(d = samRelations, 
                           vertices = nodes,
                          directed = SS$W.DIRECTED)

summary(network)

```


Identify lenders and borrowers

```{r lenders_and_borrowers}
borrowers <- unique(avgRelations$IDENT_DEUDORA)
lenders <- unique(avgRelations$IDENT_ACREEDORA)
banks <- mutate(banks, 'IS_BORROWER' = (IDENT %in% borrowers),
                            'IS_LENDER' = (IDENT %in% lenders))
# The borrower is also a lender
strictLenders <- filter(avgRelations,
                        IDENT_DEUDORA %in% lenders)$IDENT_ACREEDORA %>%
  unique()
# The lender is also a borrower
strictBorrowers <- filter(avgRelations,
                        IDENT_ACREEDORA %in% borrowers)$IDENT_DEUDORA %>%
  unique()
    
```

```{r filter_graph}
G <- network # G may be filtered
excBanksID <- NA
names(excBanksID) <- NA

if (SS$W.ALLOW.ZERO == FALSE) {
  # Delete isolated nodes
  # (its only 1 iteration for undirected graph)
  
  #edgeMode <- if_else(SS$W.WVAR == 'W_A_PR', 'in', 'out') # out for lenders, in for borrowers
  edgeMode <- 'out' # what matters is wether the node has a row of zeros in W
  # an out mean the bank owns money to othert bank, this its failure can spread. otherwise the failure does not spread
  print(paste0("Prune the graph until all nodes with no ", edgeMode, " edges are removed"))
  isolated = which(degree(G, mode=edgeMode)==0)
  excBanksID <- isolated
  while (length(isolated)>0) {
    G = delete.vertices(G, isolated)
    excBanksID <- c(excBanksID, isolated)
    
    isolated = which(degree(G, mode=edgeMode)==0)
  }
}
# WEIGHTED and UNWEIGHTED W
summary(G)
```

```{r build_graph}
# DIRECTED W
if (SS$W.DIRECTED == TRUE) {
  if(SS$W.WEIGHTED == TRUE) {
    # DIRECTED and Weighted W
    W <- create_adj_matrix(G, weighted=TRUE, row_norm=SS$W.ROW.NORM)
    spatialRegNetwork <-  spdep::mat2listw(W) 
    summary(spatialRegNetwork, zero.policy=SS$W.ALLOW.ZERO)
  } else {
    # DIRECTED and Unweighted W
  W <- create_adj_matrix(G, weighted=FALSE, row_norm=SS$W.ROW.NORM)
  spatialRegNetwork <-  spdep::mat2listw(W) 
  summary(spatialRegNetwork, zero.policy=SS$W.ALLOW.ZERO)  
  }
} else {
# UNDIRECTED W  
  # UNDIRECTED and unweighted (only possible when W is undirected)
  W <- create_adj_matrix(G, weighted=FALSE, row_norm=SS$W.ROW.NORM)
  spatialRegNetwork <-  spdep::mat2listw(W) 
  summary(spatialRegNetwork, zero.policy=SS$W.ALLOW.ZERO)

}

```

```{r}
save2Excel(W, 'W', 'WnonNorm.xlsx')
```

#### Invertibility: eigenvalues

$W$ is the row-normalised W0

```{r W_eigen}
wEigVals <- tibble('EIG_VAL' = eigen(W, symmetric=(-1)*SS$W.DIRECTED, only.values = TRUE)$values,
                   'REAL_PART' = Re(EIG_VAL),
                    'IM_PART' = Im(EIG_VAL))

any(abs(wEigVals$REAL_PART) >= 1)

wEigVals %>% 
  datatable(.)
```


```{r}
eigRealMin <- filter(wEigVals, IM_PART == 0)$REAL_PART %>%
  min(.)
rhoMin <- 1/eigRealMin

```

As shown in [p88-89]{LeSagePace2009book} shows  that the condition for invertibility only depends on the **real** eigenvalues such that $\rho$ is restricted to be in the interval ($r^{-1}_{\text{min}}, 1$) where $r^{-1}_{\text{min}}$ is the smallest-pure-real eigenvalue of $W$. The smallest-pure-real eigenvalue is `r eigRealMin` and thus $$\rho \in ( `r rhoMin`, 1)$$

Eigenvalues and max row and column sum for $W_0$ the original W before row-normalisation

```{r }
if (SS$W.DIRECTED == TRUE) {
  W0 <- as_adjacency_matrix(network, attr='weight', sparse=FALSE)
} else {
  W0 <- as_adjacency_matrix(network, sparse=FALSE)
}
              
w0EigVals <- tibble('eigenVals' = eigen(W0,
                                       symmetric=(-1)*SS$W.DIRECTED, only.values = TRUE)$values) 

any(abs(w0EigVals$eigenVals) >= 1)

w0EigVals %>% 
  datatable(.)

# when is (I - rhoW) non-singular for all |\rho|< 1/\alpha
W0rowSum <- Matrix::rowSums(W0)
W0colSum <- Matrix::colSums(W0)
which.max(W0rowSum)
which.max(W0colSum)
alpha = min(max(W0rowSum), max(W0colSum))
```

If W is not row-normalised, Keleijian & Piras (2017) establishes that
$$
(I_N - \rho W), \text{ is non-singular for all } |\rho| < 1/\alpha.
$$
where $\alpha = min(r, c)$ and $r$ is the maximum sum for a row, and $c$ the maximum sum for a column.

The maximum row sum for $W_0$ is `r max(W0rowSum)` and the maximum colum sum for $W_0$ is `r max(W0colSum)`. 
Then $(I_N - \rho W)$ is not-singular if $| \rho |< `r round(1/alpha, digits=3)`$.



These banks are excluded because they don't borrow and/or lend.
```{r}
ExcBanks <- filter(banks, IDENT %in% as.integer(names(excBanksID))) %>%
    select(IDENT, NOMRED, EXIT_DATE, failure, IS_BORROWER, IS_LENDER) 

ExcBanks %>%
  datatable(.)
```

```{r }
uLinksN <- length(E(G))
nLenders <- samRelations %>% ungroup() %>% summarise(n=n_distinct(IDENT_ACREEDORA)) %>% .$n
nBorrowers <- samRelations %>% ungroup() %>% summarise(n=n_distinct(IDENT_DEUDORA)) %>% .$n

```


## Build X and Y

Y is the failure vector, X the covariates vector

```{r X_Y}
samBanks <- filter(banks, !(IDENT %in% ExcBanks$IDENT))
nBanks <- samBanks %>% summarise(n=n_distinct(IDENT)) %>% .$n
if(length(V(G)) != nBanks) { stop("The # of banks in samBanks is not the same as the # of vertex in the graph") }

X <- samBanks %>% select(all_of(thisVars))

# 1: failure, 0: survival during the sample period
y <- if_else(samBanks$exitDateQ <= SS$Y.FAILUREHORIZON, 1, 0)

```

There are `r nLenders `  lenders, `r nBorrowers`  borrowers and `r uLinksN` unique linkes (edges) in the sample network (the final one). There are `r nBanks` entities in `samBank`.


I exclude `r NROW(excBanks)` because they are not debtors. Now I have a directed graph.


There are `r nrow(samRelations)` links in `samRelations`; `r uLinksN` of them are unique. `W` is `r nrow(W)` $\times$ `r ncol(W)` and the number of banks in `samBanks` is `r NROW(samBanks)`. They should be equal!


The following entities appear in the network but not in the banks dataframe: NROWS: `r NROW(netExcBanks)`. Should be empty!
Mean weight is `r if(exists('weight', where=samRelations)) { mean(samRelations$weight) } else { NA } `

## Desc stats

### Banks

> The number of failures is **`r sum(y)`**

```{r descStatsBanks}
descStatsT <- dplyr::bind_cols('y'=y, X, 'IDENT'=samBanks$IDENT) %>%
  descStats2(.)

  descStatsT %>%
    datatable() %>%
    formatRound(columns=c('min', 'median', 'mean', 'SD', 'max', 'CV'))
```


### Network

```{r descStats_network}
summary(spatialRegNetwork, zero.policy=SS$W.ALLOW.ZERO)
```


# Test a linear SAR
```{r estimation_sar}
model <- spatialreg::lagsarlm(formula ='y ~ log(ActivoN) + C8Est_w+ CAR_IRR_3A6+ P_ROA+ P_DEP_ARS_RATE +
  P_LOANS_ARS_RATE_W+ APRSpNF_RATE_W+ APR_USD_RATE+ APR_RATE_W',
        data = bind_cols('y'=y, X),
        listw = spatialRegNetwork,
        zero.policy = SS$W.ALLOW.ZERO)

regSumm <- summary(model)

regSumm

```


# SAVE
## Sample
```{r sample_save}
fileName <- paste0('../', SS$SAMSAVINGFOLDER, SS$IDSAM, '.rds')

if (file.exists(fileName)) { 
  warning('the file already exists. I dont overwrite it')
} else {
  saveRDS(list('y'=y, 'X'=X, 'G'=G, 'W'=W, 
               'samBanks'=samBanks, 'specs'=SS), 
        file=fileName)
}

```

